<?php

// Auto-generated file

  namespace {  final class _ { public $__chain__ = false; public const reInterpolate = '<%=([\s\S]+?)%>'; public const reEvaluate = "<%([\s\S]+?)%>"; public const reEscape = "<%-([\s\S]+?)%>"; public static $templateSettings = [ 'escape' => self::reEscape, 'evaluate' => self::reEvaluate, 'interpolate' => self::reInterpolate, 'imports' => [ '_\escape' => '__e', ], ]; private $value; public function __construct($value) { $this->value = $value; } public static function __callStatic(string $method, array $args) { if (!\is_callable("_\\$method")) { throw new \InvalidArgumentException("Function _::$method is not valid"); } return ("_\\$method")(...$args); } public function __call($method, $arguments) { $this->value = self::__callStatic($method, \array_merge([$this->value], $arguments)); return $this; } public function value() { return $this->value; } } function lodash($value): _ { return new _($value); } if (!function_exists('__')) { function __($value): _ { return new _($value); } } if (!defined('_')) { define('_', _::class); }  }
  namespace _ { use _\internal\Traits\CacheDataTrait; final class Hash implements CacheInterface { use CacheDataTrait; public function __construct() { $this->clear(); } public function set($key, $value): CacheInterface { $this->size += $this->has($key) ? 0 : 1; $this->__data__[$key] = $value; return $this; } public function get($key) { return $this->__data__[$key] ?? null; } public function has($key): bool { return \array_key_exists($key, $this->__data__); } public function clear() { $this->__data__ = []; $this->size = 0; } public function delete($key) { $result = $this->has($key); unset($this->__data__[$key]); $this->size -= $result ? 1 : 0; return $result; } }  }
  namespace _ { use _\internal\Traits\CacheDataTrait; final class MapCache implements CacheInterface { use CacheDataTrait; public function __construct(iterable $entries = null) { $this->clear(); if (null !== $entries) { foreach ($entries as $key => $entry) { $this->set($key, $entry); } } } final public function set($key, $value): CacheInterface { $data = $this->getMapData($key); $size = $data->getSize(); $data->set($key, $value); $this->size += $data->getSize() === $size ? 0 : 1; return $this; } final public function get($key) { return $this->getMapData($key)->get($key); } final public function has($key): bool { return $this->getMapData($key)->has($key); } final public function clear() { $this->size = 0; $this->__data__ = [ 'hash' => new Hash, 'map' => new ListCache, 'string' => new Hash, ]; } final public function delete($key) { $result = $this->getMapData($key)->delete($key); $this->size -= $result ? 1 : 0; return $result; } private function isKey($key) { return \is_scalar($key); } private function getMapData($key): CacheInterface { if ($this->isKey($key)) { return $this->__data__[\is_string($key) ? 'string' : 'hash']; } return $this->__data__['map']; } }  }
  namespace _ { use function _\internal\baseIteratee; function reduce(iterable $collection, $iteratee, $accumulator = null) { $func = function (iterable $array, $iteratee, $accumulator, $initAccum = null) { $length = \count(\is_array($array) ? $array : \iterator_to_array($array)); if ($initAccum && $length) { $accumulator = \current($array); } foreach ($array as $key => $value) { $accumulator = $iteratee($accumulator, $value, $key, $array); } return $accumulator; }; return $func($collection, baseIteratee($iteratee), $accumulator, null === $accumulator); }  }
  namespace _ { function eachRight($collection, callable $iteratee) { $values = \is_object($collection) ? \get_object_vars($collection) : $collection; foreach (\array_reverse($values, true) as $index => $value) { if (false === $iteratee($value, $index, $collection)) { break; } } return $collection; }  }
  namespace _ { use function _\internal\baseFlatten; function flatMapDeep(iterable $collection, callable $iteratee): array { return baseFlatten(map($collection, $iteratee), \PHP_INT_MAX); }  }
  namespace _ { use function _\internal\baseOrderBy; function orderBy(?iterable $collection, array $iteratee, array $orders): array { if (null === $collection) { return []; } return baseOrderBy($collection, $iteratee, $orders); }  }
  namespace _ { function size($collection): int { if (\is_string($collection)) { return \strlen($collection); } if (\is_array($collection) || $collection instanceof \Countable) { return \count($collection); } if ($collection instanceof \Traversable) { return \count(\iterator_to_array($collection)); } if (\is_object($collection)) { return \count(\get_object_vars($collection)); } return 0; }  }
  namespace _ { function each($collection, callable $iteratee) { $values = \is_object($collection) ? \get_object_vars($collection) : $collection; foreach ($values as $index => $value) { if (false === $iteratee($value, $index, $collection)) { break; } } return $collection; }  }
  namespace _ { use function _\internal\baseIteratee; use function _\internal\baseReduce; function reduceRight(iterable $collection, $iteratee, $accumulator = null) { return baseReduce(\array_reverse($collection instanceof \Traversable ? \iterator_to_array($collection, true) : $collection, true), baseIteratee($iteratee), $accumulator, null === $accumulator); }  }
  namespace _ { use function _\internal\baseIteratee; function map($collection, $iteratee): array { $values = []; if (\is_array($collection)) { $values = $collection; } elseif ($collection instanceof \Traversable) { $values = \iterator_to_array($collection); } elseif (\is_object($collection)) { $values = \get_object_vars($collection); } $callable = baseIteratee($iteratee); return \array_map(function ($value, $index) use ($callable, $collection) { return $callable($value, $index, $collection); }, $values, \array_keys($values)); }  }
  namespace _ { use function _\internal\createAggregator; function partition(iterable $collection, $predicate = null): array { return createAggregator(function ($result, $value, $key) { $result[$key ? 0 : 1][] = $value; return $result; }, function () { return [[], []]; })($collection, $predicate); }  }
  namespace _ { use function _\internal\baseIteratee; function every(iterable $collection, $predicate): bool { $iteratee = baseIteratee($predicate); foreach ($collection as $key => $value) { if (!$iteratee($value, $key, $collection)) { return false; } } return true; }  }
  namespace _ { use function _\internal\baseIteratee; function find(iterable $collection, $predicate = null, int $fromIndex = 0) { $iteratee = baseIteratee($predicate); foreach (\array_slice(\is_array($collection) ? $collection : \iterator_to_array($collection), $fromIndex) as $key => $value) { if ($iteratee($value, $key, $collection)) { return $value; } } return null; }  }
  namespace _ { function shuffle(array $array = []): array { \shuffle($array); return $array; }  }
  namespace _ { use function _\internal\baseFlatten; function flatMap(iterable $collection, callable $iteratee): array { return baseFlatten(map($collection, $iteratee), 1); }  }
  namespace _ { use function _\internal\baseIteratee; function reject(iterable $collection, $predicate = null): array { return filter($collection, negate(baseIteratee($predicate))); }  }
 namespace _ { use function _\internal\baseInvoke; use function _\internal\baseRest; function invokeMap(iterable $collection, $path, array $args = []): array { return baseRest(function ($collection, $path, $args) { $isFunc = \is_callable($path); $result = []; each($collection, function ($value) use (&$result, $isFunc, $path, $args) { $result[] = $isFunc ? $path($value, ...$args) : baseInvoke($value, $path, $args); }); return $result; })($collection, $path, ...$args); }  }
  namespace _ { function sampleSize(array $array, int $n = 1): array { $result = []; $count = \count($array); foreach ((array) \array_rand($array, $n > $count ? $count : $n) as $index) { $result[] = $array[$index]; } return $result; }  }
  namespace _ { use function _\internal\baseIteratee; function filter(iterable $array, $predicate = null): array { $iteratee = baseIteratee($predicate); $result = \array_filter( \is_array($array) ? $array : \iterator_to_array($array), function ($value, $key) use ($array, $iteratee) { return $iteratee($value, $key, $array); }, \ARRAY_FILTER_USE_BOTH ); return \array_values($result); }  }
  namespace _ { function sample(array $array) { $key = \array_rand($array, 1); return $array[$key]; }  }
  namespace _ { use function _\internal\baseIteratee; function some(iterable $collection, $predicate = null): bool { $iteratee = baseIteratee($predicate); foreach ($collection as $key => $value) { if ($iteratee($value, $key, $collection)) { return true; } } return false; }  }
  namespace _ { use function _\internal\baseIteratee; function sortBy($collection, $iteratees): array { if (null === $collection) { return []; }; if (\is_callable($iteratees) || !\is_iterable($iteratees)) { $iteratees = [$iteratees]; } $result = \is_object($collection) ? \get_object_vars($collection) : $collection; foreach ($iteratees as $callable) { usort($result, function ($a, $b) use ($callable) { $iteratee = baseIteratee($callable); return $iteratee($a, $b) <=> $iteratee($b, $a); }); } return $result; }  }
  namespace _ { use function _\internal\createAggregator; function keyBy(iterable $collection, $iteratee): array { return createAggregator(function ($result, $value, $key) { $result[$key] = $value; return $result; })($collection, $iteratee); }  }
  namespace _ { use function _\internal\createAggregator; function groupBy(iterable $collection, $iteratee): array { return createAggregator(function ($result, $value, $key) { if (!isset($result[$key])) { $result[$key] = []; } $result[$key][] = $value; return $result; })($collection, $iteratee); }  }
  namespace _ { use function _\internal\baseFlatten; function flatMapDepth(iterable $collection, callable $iteratee, int $depth = 1): array { return baseFlatten(map($collection, $iteratee), $depth); }  }
  namespace _ { use function _\internal\createAggregator; function countBy(iterable $collection, callable $iteratee): array { return createAggregator(function ($result, $key, $value) { if (!isset($result[$value])) { $result[$value] = 0; } $result[$value]++; return $result; })($collection, $iteratee); }  }
  namespace _ { use function _\internal\baseIteratee; function findLast(iterable $collection, $predicate = null, int $fromIndex = 0) { $iteratee = baseIteratee($predicate); foreach (\array_slice(\array_reverse(\is_array($collection) ? $collection : \iterator_to_array($collection), true), $fromIndex) as $key => $value) { if ($iteratee($value, $key, $collection)) { return $value; } } return null; }  }
  namespace _ { use Symfony\Component\PropertyAccess\PropertyAccess; function property($path): callable { $propertyAccess = PropertyAccess::createPropertyAccessorBuilder() ->disableExceptionOnInvalidIndex() ->getPropertyAccessor(); return function ($value, $index = 0, $collection = []) use ($path, $propertyAccess) { $path = \implode('.', (array) $path); if (\is_array($value)) { if (false !== \strpos($path, '.')) { $paths = \explode('.', $path); foreach ($paths as $path) { $value = property($path)($value, $index, $collection); } return $value; } if (\is_string($path) && $path[0] !== '[' && $path[-1] !== ']') { $path = "[$path]"; } } return $propertyAccess->getValue($value, $path); }; }  }
  namespace _ { function identity($value = null) { return $value; }  }
  namespace _ { function attempt(callable $func, ...$args) { try { return $func(...$args); } catch (\ParseError | \Error | \Throwable | \SoapFault | \DOMException | \PDOException $e) { return $e; } }  }
  namespace _ { use function _\internal\baseFlatten; function flattenDepth(array $array, int $depth = 1): array { return baseFlatten($array, $depth); }  }
  namespace _ { function difference(array $array, array ...$values): array { return \array_values(\array_diff($array, ...$values)); }  }
  namespace _ { use function _\internal\baseSet; function zipObjectDeep(array $props = [], array $values = []): \stdClass { $result = new \stdClass; $index = -1; $length = \count($props); $props = \array_values($props); $values = \array_values($values); while (++$index < $length) { $value = $values[$index] ?? null; baseSet($result, $props[$index], $value); } return $result; }  }
  namespace _ { use function _\internal\baseIteratee; function findLastIndex(array $array, $predicate, int $fromIndex = null): int { $length = \count($array); $index = $fromIndex ?? $length - 1; if ($index < 0) { $index = \max($length + $index, 0); } $iteratee = baseIteratee($predicate); foreach (\array_reverse($array, true) as $key => $value) { if ($iteratee($value, $key, $array)) { return $index; } $index--; } return -1; }  }
  namespace _ { function lastIndexOf(array $array, $value, int $fromIndex = null): int { $index = \count($array) - 1; if (null !== $fromIndex) { $index = $fromIndex > 0 ? $fromIndex : \count($array) - 1; $array = \array_slice($array, 0, -$fromIndex + 1); }; foreach (\array_reverse($array, false) as $v) { if (isEqual($value, $v)) { return $index; } $index--; } return -1; }  }
  namespace _ { use function _\internal\baseIteratee; use function _\internal\basePullAll; function pullAllBy(array &$array, array $values, $iteratee): array { return basePullAll($array, $values, baseIteratee($iteratee)); }  }
  namespace _ { use function _\internal\baseUniq; function uniqWith(array $array, callable $comparator): array { return baseUniq($array, null, $comparator); }  }
  namespace _ { use function _\internal\basePullAll; function pullAllWith(array &$array, array $values, callable $comparator): array { return basePullAll($array, $values, null, $comparator); }  }
  namespace _ { use function _\internal\baseRest; function zip(array ...$arrays): array { return baseRest('\_\unzip')(...$arrays); }  }
  namespace _ { function compact(?array $array): array { return \array_values(\array_filter($array ?? [])); }  }
  namespace _ { function zipWith(...$arrays): array { $iteratee = \is_callable(\end($arrays)) ? \array_pop($arrays) : null; return unzipWith($arrays, $iteratee); }  }
  namespace _ { function uniq(array $array = []): array { return \array_unique($array); }  }
  namespace _ { function zipObject(array $props = [], array $values = []) { $result = new \stdClass; $index = -1; $length = \count($props); $props = \array_values($props); $values = \array_values($values); while (++$index < $length) { $value = $values[$index] ?? null; $result->{$props[$index]} = $value; } return $result; }  }
  namespace _ { use function _\internal\baseIteratee; use function _\internal\baseUniq; function uniqBy(array $array, $iteratee): array { return baseUniq($array, baseIteratee($iteratee)); }  }
  namespace _ { use function _\internal\baseIteratee; function takeRightWhile(array $array, $predicate): array { $iteratee = baseIteratee($predicate); $result = []; foreach (array_reverse($array, true) as $index => $value) { if ($iteratee($value, $index, $array)) { $result[$index] = $value; } } return array_reverse($result); }  }
  namespace _ { use function _\internal\baseIteratee; function takeWhile(array $array, $predicate): array { $result = []; $iteratee = baseIteratee($predicate); foreach ($array as $index => $value) { if ($iteratee($value, $index, $array)) { $result[$index] = $value; } } return $result; }  }
  namespace _ { function takeRight(array $array, int $n = 1): array { if (1 > $n) { return []; } return array_slice($array, -$n); }  }
  namespace _ { use function _\internal\baseFlatten; function differenceWith(array $array, ...$values): array { if (!$array) { return []; } if (!\is_callable(\end($values))) { return difference($array, ...$values); } $comparator = \array_pop($values); $values = baseFlatten($values, 1, 'is_array', true, null); $valuesLength = \count($values); $result = []; foreach ($array as $value) { $valuesIndex = $valuesLength; while ($valuesIndex--) { if ($comparator($value, $values[$valuesIndex])) { continue 2; } } $result[] = $value; } return $result; }  }
  namespace _ { function initial(array $array): array { \array_pop($array); return $array; }  }
  namespace _ { function dropRightWhile(array $array, callable $predicate): array { \end($array); $length = \count($array); $index = \key($array); while ($length && $predicate($array[$index], $index, $array)) { array_pop($array); $length--; \end($array); $index = \key($array); } return $array; }  }
  namespace _ { function indexOf(array $array, $value, int $fromIndex = null): int { $inc = true; $index = 0; if (null !== $fromIndex) { $index = $fromIndex >= 0 ? $fromIndex : \count($array) - 1; if ($fromIndex < 0) { $array = \array_reverse($array, false); $inc = false; } }; foreach ($array as $v) { if (isEqual($value, $v)) { return $index; } $inc ? $index++ : $index--; } return -1; }  }
  namespace _ { use function _\internal\arrayMap; use function _\internal\baseProperty; use function _\internal\baseTimes; function unzip(array $array): array { if (!\count($array)) { return []; } $length = 0; $array = \array_filter($array, function ($group) use (&$length) { if (\is_array($group)) { $length = \max(\count($group), $length); return true; } }); return baseTimes($length, function ($index) use ($array) { return arrayMap($array, baseProperty($index)); }); }  }
  namespace _ { function slice(array $array, int $start, int $end = null): array { return \array_slice($array, $start, $end); }  }
  namespace _ { function drop(array $array, int $n = 1): array { return \array_slice($array, $n); }  }
  namespace _ { use function _\internal\baseRest; function without(array $array, ...$values): array { return baseRest('\_\difference')($array, ...$values); }  }
  namespace _ { function dropWhile(array $array, callable $predicate): array { \reset($array); $count = \count($array); $length = 0; $index = \key($array); while ($length <= $count && $predicate($array[$index], $index, $array)) { array_shift($array); \reset($array); $length++; $index = \key($array); } return $array; }  }
  namespace _ { use function _\internal\baseIntersection; function intersectionWith(...$arrays ): array { $copy = $arrays; $comparator = \array_pop($arrays); if (!\is_callable($comparator)) { $arrays = $copy; $comparator = null; } return baseIntersection($arrays, null, $comparator); }  }
  namespace _ { function head(array $array) { reset($array); return current($array) ?: null; } function first(array $array) { return head($array); }  }
  namespace _ { function dropRight(array $array, int $n = 1): array { $count = \count($array); if ($n > $count) { $n = $count; } return \array_slice($array, 0, $count - $n); }  }
  namespace _ { function concat($array, ...$values): array { $check = function ($value): array { return \is_array($value) ? $value : [$value]; }; return \array_merge($check($array), ...\array_map($check, $values)); }  }
  namespace _ { function remove(array &$array, callable $predicate): array { $resultArray = []; $array = \array_filter($array, function ($val, $key) use ($predicate, $array, &$resultArray) { $result = $predicate($val, $key, $array); if ($result) { $resultArray[] = $val; } return !$result; }, \ARRAY_FILTER_USE_BOTH); $array = \array_values($array); return $resultArray; }  }
  namespace _ { function chunk(?array $array, int $number): array { if ($number < 1) { return []; } return \array_chunk($array ?? [], $number, false); }  }
  namespace _ { function take(array $array, int $n = 1): array { if (1 > $n) { return []; } array_splice($array, $n); return $array; }  }
  namespace _ { function last(array $array) { return \end($array) ?: null; }  }
  namespace _ { function tail(array $array): array { array_shift($array); return $array; }  }
  namespace _ { function pull(array &$array, ...$values): array { $array = \array_filter($array, function ($val) use ($values) { return !\in_array($val, $values, true); }); $array = \array_values($array); return $array; }  }
  namespace _ { function fromPairs(array $pairs): \stdClass { if (!\count($pairs)) { return new \stdClass(); } $result = new \stdClass(); foreach ($pairs as $pair) { $result->{$pair[0]} = $pair[1]; } return $result; }  }
  namespace _ { function intersection(array ...$arrays): array { return \array_intersect(...$arrays); }  }
  namespace _ { function pullAt(array &$array, $indexes): array { $indexes = (array) $indexes; $pulled = []; $array = \array_filter($array, function ($val, $key) use ($indexes, &$pulled) { $inArray = \in_array($key, $indexes); if ($inArray) { $pulled[] = $val; } return !$inArray; }, \ARRAY_FILTER_USE_BOTH); $array = \array_values($array); return $pulled; }  }
  namespace _ { function pullAll(array &$array, array $values): array { return pull($array, ...$values); }  }
  namespace _ { function union(array ...$arrays): array { return array_unique(array_merge(...$arrays)); }  }
  namespace _ { use function _\internal\baseFlatten; function flatten(array $array = null): array { return baseFlatten($array, 1); }  }
  namespace _ { use function _\internal\baseFlatten; use function _\internal\baseUniq; function unionWith(... $arrays): array { $comparator = \array_pop($arrays); if (!\is_callable($comparator)) { throw new \InvalidArgumentException(__FUNCTION__.' expects the last value passed to be callable'); } return baseUniq(baseFlatten($arrays, 1, '\is_array', true), null, $comparator); }  }
  namespace _ { use function _\internal\baseIteratee; function findIndex(array $array, $predicate, int $fromIndex = null): int { $length = \count($array); if (!$length) { return -1; } $index = $fromIndex ?? 0; if ($index < 0) { $index = \min($length + $index, 0); } $iteratee = baseIteratee($predicate); foreach ($array as $key => $value) { if ($iteratee($value, $key, $array)) { return $index; } $index++; } return -1; }  }
  namespace _ { use function _\internal\baseFlatten; function flattenDeep(array $array): array { return baseFlatten($array, PHP_INT_MAX); }  }
  namespace _ { use function _\internal\arrayMap; function unzipWith(array $array, ?callable $iteratee = null): array { if (!\count($array)) { return []; } $result = unzip($array); if (!is_callable($iteratee)) { return $result; } return arrayMap($result, function ($group) use ($iteratee) { return $iteratee(...$group); }); }  }
  namespace _ { function nth(array $array, int $n) { return \array_values($array)[$n < 0 ? \count($array) + $n : $n] ?? null; }  }
  namespace _ { use function _\internal\baseFlatten; function differenceBy(array $array, ...$values): array { if (!$array) { return []; } if (!\is_callable(\end($values))) { return difference($array, ...$values); } $iteratee = \array_pop($values); $values = \array_map($iteratee, baseFlatten($values, 1, 'is_array', true, null)); $valuesLength = \count($values); $result = []; foreach ($array as $value) { $computed = $iteratee($value); $valuesIndex = $valuesLength; while ($valuesIndex--) { if ($computed === $values[$valuesIndex]) { continue 2; } } $result[] = $value; } return $result; }  }
  namespace _ { use function _\internal\baseFlatten; use function _\internal\baseIteratee; use function _\internal\baseUniq; function unionBy(...$arrays): array { return baseUniq(baseFlatten($arrays, 1, '\is_array', true), baseIteratee(\array_pop($arrays))); }  }
  namespace _ { use function _\internal\baseIntersection; use function _\internal\baseIteratee; function intersectionBy(...$arrays): array { $iteratee = \array_pop($arrays); return baseIntersection($arrays, baseIteratee($iteratee)); }  }
  namespace _ { function chain($value): \_ { $result = __($value); $result->__chain__ = true; return $result; }  }
  namespace _ { function now(): int { return (int) (\microtime(true) * 1000); }  }
  namespace _\internal { function baseUnary($func) { return function ($value) use ($func) { return $func($value); }; }  }
  namespace _\internal { function stringToArray(string $string): array { return hasUnicode($string) ? unicodeToArray($string) : \str_split($string); }  }
  namespace _\internal { function createMathOperation(callable $operator, $defaultValue) { return function ($value, $other) use ($defaultValue, $operator) { if (null === $value && null === $other) { return $defaultValue; } $result = null; if (null !== $value) { $result = $value; } if (null !== $other) { if (null === $result) { return $other; } $result = $operator($value, $other); } return $result; }; }  }
  namespace _\internal { use function _\each; function createAggregator($setter, $initializer = null) { return function ($collection, $iteratee) use ($setter, $initializer) { $accumulator = null !== $initializer ? $initializer() : []; $func = function ($collection, $setter, &$accumulator, $iteratee) { each($collection, function ($value, $key, $collection) use ($setter, &$accumulator, $iteratee) { $accumulator = $setter($accumulator, $value, $iteratee($value), $collection); }); return $accumulator; }; return $func($collection, $setter, $accumulator, baseIteratee($iteratee)); }; }  }
  namespace _\internal { use function _\isEqual; use function _\property; function baseMatches($source): callable { return function ($value, $index, $collection) use ($source): bool { if ($value === $source || isEqual($value, $source)) { return true; } if (\is_array($source) || $source instanceof \Traversable) { foreach ($source as $k => $v) { if (!isEqual(property($k)($value, $index, $collection), $v)) { return false; } } return true; } return false; }; }  }
  namespace _\internal { function baseTimes(int $n, callable $iteratee) { $index = -1; $result = []; while (++$index < $n) { $result[$index] = $iteratee($index); } return $result; }  }
  namespace _\internal { function arrayMap(?array $array, callable $iteratee) { $index = -1; $length = null === $array ? 0 : \count($array); $result = []; while (++$index < $length) { $result[$index] = $iteratee($array[$index], $index, $array); } return $result; }  }
  namespace _\internal { const rsAstralRange = '\\x{e800}-\\x{efff}'; const rsComboMarksRange = '\\x{0300}-\\x{036f}'; const reComboHalfMarksRange = '\\x{fe20}-\\x{fe2f}'; const rsComboSymbolsRange = '\\x{20d0}-\\x{20ff}'; const rsComboRange = rsComboMarksRange.reComboHalfMarksRange.rsComboSymbolsRange; const rsDingbatRange = '\\x{2700}-\\x{27bf}'; const rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff'; const rsMathOpRange = '\\xac\\xb1\\xd7\\xf7'; const rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf'; const rsPunctuationRange = '\\x{2000}-\\x{206f}'; const rsSpaceRange = ' \\t\\x0b\\f\\xa0\\x{feff}\\n\\r\\x{2028}\\x{2029}\\x{1680}\\x{180e}\\x{2000}\\x{2001}\\x{2002}\\x{2003}\\x{2004}\\x{2005}\\x{2006}\\x{2007}\\x{2008}\\x{2009}\\x{200a}\\x{202f}\\x{205f}\\x{3000}'; const rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde'; const rsVarRange = '\\x{fe0e}\\x{fe0f}'; const rsBreakRange = rsMathOpRange.rsNonCharRange.rsPunctuationRange.rsSpaceRange; const rsApos = "[\\x{2019}]"; const rsBreak = '['.rsBreakRange.']'; const rsCombo = '['.rsComboRange.']'; const rsDigits = '\\d+'; const rsDingbat = '['.rsDingbatRange.']'; const rsLower = '['.rsLowerRange.']'; const rsMisc = '[^'.rsAstralRange.rsBreakRange.rsDigits.rsDingbatRange.rsLowerRange.rsUpperRange.']'; const rsFitz = '\\x{e83c}[\\x{effb}-\\x{efff}]'; const rsModifier = '(?:'.rsCombo.'|'.rsFitz.')'; const rsNonAstral = '[^'.rsAstralRange.']'; const rsRegional = '(?:\\x{e83c}[\\x{ede6}-\\x{edff}]){2}'; const rsSurrPair = '[\\x{e800}-\\x{ebff}][\\x{ec00}-\\x{efff}]'; const rsUpper = '['.rsUpperRange.']'; const rsZWJ = '\\x{200d}'; const rsMiscLower = '(?:'.rsLower.'|'.rsMisc.')'; const rsMiscUpper = '(?:'.rsUpper.'|'.rsMisc.')'; const rsOptContrLower = '(?:'.rsApos.'(?:d|ll|m|re|s|t|ve))?'; const rsOptContrUpper = '(?:'.rsApos.'(?:D|LL|M|RE|S|T|VE))?'; const reOptMod = rsModifier.'?'; const rsOptVar = '['.rsVarRange.']?'; define('rsOptJoin', '(?:'.rsZWJ.'(?:'.implode('|', [rsNonAstral, rsRegional, rsSurrPair]).')'.rsOptVar.reOptMod.')*'); const rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)'; const rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)'; const rsSeq = rsOptVar.reOptMod.rsOptJoin; define('rsEmoji', '(?:'.implode('|', [rsDingbat, rsRegional, rsSurrPair]).')'.rsSeq); const rsAstral = '['.rsAstralRange.']'; const rsNonAstralCombo = rsNonAstral.rsCombo.'?'; define('rsSymbol', '(?:'.implode('|', [rsNonAstralCombo, rsCombo, rsRegional, rsSurrPair, rsAstral]).')'); const reUnicode = rsFitz.'(?='.rsFitz.')|'.rsSymbol.rsSeq;  }
  namespace _\internal { function toKey($value): string { if (\is_string($value)) { return $value; } $result = (string) $value; return ('0' === $result && (1 / $value) === -INF) ? '-0' : $result; }  }
  namespace _\internal { function overRest(callable $func, $start, callable $transform): callable { $parameters = (new \ReflectionFunction($func))->getNumberOfParameters(); $start = max($start ?? $parameters - 1, 0); return function () use ($func, $start, $transform) { $args = \func_get_args(); $index = -1; $length = \max(\count($args) - $start, 0); $array = []; while (++$index < $length) { $array[$index] = $args[$start + $index]; } $index = -1; $otherArgs = []; while (++$index < $start) { $otherArgs[$index] = $args[$index]; } $otherArgs[$start] = $transform($array); return $func(...$otherArgs); }; }  }
  namespace _\internal\Traits { trait CacheDataTrait { private $__data__ = []; private $size; public function getSize(): int { return $this->size; } }  }
  namespace _\internal { function unicodeToArray(string $string): array { if (\preg_match_all('#'.reUnicode.'#u', $string, $matches)) { return $matches[0]; } return []; }  }
  namespace _\internal { function flatRest(callable $func): callable { return shortOut(overRest($func, null, '\_\flatten')); }  }
  namespace _\internal { function baseRest(callable $func, $start = null): callable { return overRest($func, $start, '\_\identity'); }  }
  namespace _\internal { use function _\property; function isIterateeCall($value, $index = null, $object = null) { if (!\is_object($object) || !\is_array($object)) { return false; } $type = \gettype($index); if (null === $index || ('integer' !== $type && 'string' !== $type)) { return false; } if (\is_array($object)) { return isset($object[$index]) && property($index)($value) === $value; } if (\is_object($object)) { return \property_exists($object, $index) && property($index)($value) === $value; } return false; }  }
  namespace _\internal { function unicodeSize(string $string): int { return \preg_match_all(reUnicode, $string) ?: 0; }  }
  namespace _\internal { use function _\property; function baseGet($object, $path) { $path = castPath($path, $object); $index = 0; $length = \count($path); while ($object !== null && $index < $length) { $object = property(toKey($path[$index++]))($object); } return ($index > 0 && $index === $length) ? $object : null; }  }
  namespace _\internal { function basePullAll(&$array, array $values, ?callable $iteratee, callable $comparator = null) { $indexOf = $comparator ? '_\\internal\\baseIndexOfWith' : '_\\indexOf'; $seen = $array; if ($iteratee) { $seen = \array_map($iteratee, $array); } foreach ($values as $value) { $fromIndex = 0; $computed = $iteratee ? $iteratee($value) : $value; while (($fromIndex = $indexOf($seen, $computed, $fromIndex, $comparator)) > -1) { \array_splice($array, $fromIndex, 1); if ($seen !== $array) { \array_splice($seen, $fromIndex, 1); } } } return $array; }  }
  namespace _\internal { function baseFlatten(?array $array, int $depth, callable $predicate = null, bool $isStrict = null, array $result = null): array { $result = $result ?? []; if ($array === null) { return $result; } $predicate = $predicate ?? '_\internal\isFlattenable'; foreach ($array as $value) { if ($depth > 0 && $predicate($value)) { if ($depth > 1) { $result = baseFlatten($value, $depth - 1, $predicate, $isStrict, $result); } else { arrayPush($result, $value); } } elseif (!$isStrict) { $result[\count($result)] = $value; } } return $result; }  }
  namespace _\internal { function castSlice(array $array, int $start, ?int $end = null): array { $length = \count($array); $end = null === $end ? $length : $end; return (!$start && $end >= $length) ? $array : \array_slice($array, $start, $end); }  }
  namespace _\internal { function isFlattenable($value): bool { return \is_array($value) && ([] === $value || \range(0, \count($value) - 1) === \array_keys($value)); }  }
  namespace _\internal { function arrayIncludesWith(?array $array, $value, callable $comparator) { $array = $array ?? []; foreach ($array as $v) { if ($comparator($value, $v)) { return true; } } return false; }  }
  namespace _\internal { const reIsDeepProp = '#\.|\[(?:[^[\]]*|(["\'])(?:(?!\1)[^\\\\]|\\.)*?\1)\]#'; const reIsPlainProp = '/^\w*$/'; function isKey($value, $object = []): bool { if (\is_array($value)) { return false; } if (\is_numeric($value)) { return true; } return \preg_match(reIsPlainProp, $value) || !\preg_match(reIsDeepProp, $value) || (null !== $object && isset(((object) $object)->$value)); }  }
  namespace _\internal { function baseProperty($key) { return function ($object) use ($key) { return null === $object ? null : $object[$key]; }; }  }
  namespace _\internal { use function _\isEqual; use function _\property; function baseMatchesProperty($property, $source): callable { return function ($value, $index, $collection) use ($property, $source) { return isEqual(property($property)($value, $index, $collection), $source); }; }  }
  namespace _\internal { function castPath($value, $object): array { if (\is_array($value)) { return $value; } return isKey($value, $object) ? [$value] : stringToPath((string) $value); }  }
  namespace _\internal { use function _\map; use function _\sortBy; function baseOrderBy(iterable $collection, array $iteratees, array $orders): array { $index = -1; $iteratees = arrayMap($iteratees, baseUnary('\_\internal\baseIteratee')); $result = map($collection, function ($value) use ($iteratees, &$index) { $criteria = arrayMap($iteratees, function ($iteratee) use ($value) { return $iteratee($value); }); return ['criteria' => $criteria, 'index' => ++$index, 'value' => $value]; }); return map(sortBy($result, function ($object, $other) use ($orders) { return compareMultiple($object, $other, $orders); }), 'value'); }  }
  namespace _\internal { const HOT_COUNT = 800; const HOT_SPAN = 16; function shortOut(callable $func): callable { $count = 0; $lastCalled = 0; return function () use ($func, &$count, &$lastCalled) { $stamp = microtime(true); $remaining = HOT_SPAN - ($stamp - $lastCalled); $lastCalled = $stamp; if ($remaining > 0) { if (++$count >= HOT_COUNT) { return func_get_arg(0); } } else { $count = 0; } return $func(...func_get_args()); }; }  }
  namespace _\internal { use function _\property; function baseIteratee($value): callable { if (\is_callable($value)) { return $value; } if (null === $value) { return '_\identity'; } if (\is_array($value)) { return 2 === \count($value) && [0, 1] === \array_keys($value) ? baseMatchesProperty($value[0], $value[1]) : baseMatches($value); } return property($value); }  }
  namespace _\internal { function compareMultiple($object, $other, $orders) { $index = -1; $objCriteria = $object['criteria']; $othCriteria = $other['criteria']; $length = \count($objCriteria); $ordersLength = \count($orders); while (++$index < $length) { $result = $objCriteria[$index] <=> $othCriteria[$index]; if ($result) { if ($index >= $ordersLength) { return $result; } $order = $orders[$index]; return $result * ('desc' === $order ? -1 : 1); } } return $object['index'] - $other['index']; }  }
  namespace _\internal { use function _\eq; function assocIndexOf(array $array, $key): int { $length = \count($array); while ($length--) { if (eq($array[$length][0], $key)) { return $length; } } return -1; }  }
  namespace _\internal { function parent($object, $path) { return count($path) < 2 ? $object : null; }  }
  namespace _\internal { use function _\indexOf; function arrayIncludes(?array $array, $value) { return null !== $array && indexOf($array, $value, 0) > -1; }  }
  namespace _\internal { const reLeadingDot = '/^\./'; const rePropName = '#[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["\'])((?:(?!\2)[^\\\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))#'; const reEscapeChar = '/\\(\\)?/g'; function stringToPath(...$args) { return memoizeCapped(function ($string) { $result = []; if (\preg_match(reLeadingDot, $string)) { $result[] = ''; } \preg_match_all(rePropName, $string, $matches, PREG_SPLIT_DELIM_CAPTURE); foreach ($matches as $match) { $result[] = $match[1] ?? $match[0]; } return $result; })(...$args); }  }
  namespace _\internal { function baseUniq(array $array, callable $iteratee = null, callable $comparator = null) { $index = -1; $includes = '\_\internal\arrayIncludes'; $length = \count($array); $isCommon = true; $result = []; $seen = $result; if ($comparator) { $isCommon = false; $includes = '\_\internal\arrayIncludesWith'; } else { $seen = $iteratee ? [] : $result; } while (++$index < $length) { $value = $array[$index]; $computed = $iteratee ? $iteratee($value) : $value; $value = ($comparator || $value !== 0) ? $value : 0; if ($isCommon && $computed) { $seenIndex = \count($seen); while ($seenIndex--) { if ($seen[$seenIndex] === $computed) { continue 2; } } if ($iteratee) { $seen[] = $computed; } $result[] = $value; } elseif (!$includes($result, $computed, $comparator)) { if ($seen !== $result) { $seen[] = $computed; } $result[] = $value; } } return $result; }  }
  namespace _\internal { function unicodeWords(string $string): array { $regex = '#'.\implode('|', [ rsUpper.'?'.rsLower.'+'.rsOptContrLower.'(?='.\implode('|', [rsBreak, rsUpper, '$']).')', rsMiscUpper.'+'.rsOptContrUpper.'(?='.\implode('|', [rsBreak, rsUpper.rsMiscLower, '$']).')', rsUpper.'?'.rsMiscLower.'+'.rsOptContrLower, rsUpper.'+'.rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji, ]).'#u'; if (\preg_match_all($regex, $string, $matches) > 0) { return $matches[0]; } return []; }  }
  namespace _\internal { use function _\memoize; function memoizeCapped(callable $func) { $MaxMemoizeSize = 500; $result = memoize($func, function ($key) use ($MaxMemoizeSize) { if ($this->cache->getSize() === $MaxMemoizeSize) { $this->cache->clear(); } return $key; }); return $result; }  }
  namespace _\internal { function baseIntersection($arrays, ?callable $iteratee, $comparator = null) { $includes = $comparator ? '_\internal\arrayIncludesWith' : '_\internal\arrayIncludes'; $length = \count($arrays[0]); $othLength = \count($arrays); $othIndex = $othLength; $caches = []; $maxLength = INF; $result = []; while ($othIndex--) { $array =& $arrays[$othIndex]; if ($othIndex && $iteratee) { $array = \array_map($iteratee, $array); } $maxLength = \min(\count($array), $maxLength); $caches[$othIndex] = !$comparator && $iteratee ? [] : null; } $array = $arrays[0]; $index = -1; $seen = $caches[0]; while (++$index < $length && \count($result) < $maxLength) { $value = $array[$index]; $computed = $iteratee ? $iteratee($value) : $value; $value = ($comparator ?: $value !== 0) ? $value : 0; if (!($seen ? \is_scalar($computed) && isset($seen[$computed]) : $includes($result, $computed, $comparator))) { $othIndex = $othLength; while (--$othIndex) { $cache = $caches[$othIndex]; if (!(!empty($cache) ? isset($cache[$computed]) : $includes($arrays[$othIndex], $computed, $comparator))) { continue 2; } } if (empty($seen)) { $seen[] = $computed; } $result[] = $value; } } return $result; }  }
  namespace _\internal { function baseSet($object, $path, $value, callable $customizer = null) { if (!\is_object($object)) { return $object; } $path = castPath($path, $object); $index = -1; $length = \count($path); $lastIndex = $length - 1; $nested = $object; while ($nested !== null && ++$index < $length) { $key = toKey($path[$index]); if ($index !== $lastIndex) { $objValue = \is_array($nested) ? ($nested[$key] ?? null) : ($nested->$key ?? null); $newValue = $customizer ? $customizer($objValue, $key, $nested) : $objValue; if (null === $newValue) { $newValue = \is_object($objValue) ? $objValue : (\is_numeric($path[$index + 1]) ? [] : new \stdClass()); } if (\is_array($nested)) { $nested[$key] = $newValue; } else { $nested->{$key} = $newValue; } if (\is_array($nested)) { $nested = &$nested[$key]; } else { $nested = &$nested->$key; } continue; } $nested->{$key} = $value; } return $object; }  }
  namespace _\internal { function stringSize(string $string): int { return hasUnicode($string) ? unicodeSize($string) : \strlen($string); }  }
 namespace _\internal { use function _\last; function baseInvoke($object, $path, $args) { $path = castPath($path, $object); $object = parent($object, $path); $func = null === $object ? $object : [$object, toKey(last($path))]; return \is_callable($func) ? $func($object, ...$args) : null; }  }
  namespace _\internal { function basePickBy($object, $paths, callable $predicate): \stdClass { $index = -1; $length = \is_array($paths) ? \count($paths) : \strlen($paths); $result = new \stdClass(); while (++$index < $length) { $path = $paths[$index]; $value = baseGet($object, $path); if ($predicate($value, $path)) { baseSet($result, castPath($path, $object), $value); } } return $result; }  }
  namespace _\internal { function arrayPush(&$array, $values) { $index = -1; $length = \is_array($values) ? \count($values) : \strlen($values); $offset = \count($array); while (++$index < $length) { $array[$offset + $index] = $values[$index]; } return $array; }  }
  namespace _\internal { function basePick($object, $paths): \stdClass { return basePickBy($object, $paths, function ($value, $path) use ($object) { return property_exists($object, $path) || method_exists($object, 'get'.(ucfirst($path))); }); }  }
  namespace _\internal { const reHasUnicode = '['.rsZWJ.rsAstralRange.rsComboRange.rsVarRange.']'; function hasUnicode(string $string): bool { return \preg_match('#'.reHasUnicode.'#u', $string) > 0; }  }
  namespace _\internal { function baseIndexOfWith(array $array, $value, int $fromIndex, $comparator) { $index = $fromIndex - 1; foreach (\array_slice($array, $fromIndex, null, true) as $val) { ++$index; if ($comparator($val, $value)) { return $index; } } return -1; }  }
  namespace _\internal { function baseReduce(iterable $array, $iteratee, $accumulator, $initAccum = null) { $length = \is_array($array) || $array instanceof \Countable ? \count($array) : 0; if ($initAccum && $length) { $accumulator = \current($array); } foreach ($array as $key => $value) { $accumulator = $iteratee($accumulator, $value, $key, $array); } return $accumulator; }  }
  namespace _ { interface CacheInterface { public function set($key, $value): CacheInterface; public function get($key); public function has($key): bool; public function clear(); public function delete($key); public function getSize(); }  }
  namespace _ { use function _\internal\arrayMap; use function _\internal\baseFlatten; use function _\internal\baseRest; use function _\internal\baseUnary; function overArgs(callable $func, array $transforms): callable { return baseRest(function ($func, $transforms) { $transforms = (\count($transforms) == 1 && \is_array($transforms[0])) ? arrayMap($transforms[0], baseUnary('\_\internal\baseIteratee')) : arrayMap(baseFlatten($transforms, 1), baseUnary('\_\internal\baseIteratee')); $funcsLength = \count($transforms); return baseRest(function ($args) use ($funcsLength, $transforms, $func) { $index = -1; $length = \min(\count($args), $funcsLength); while (++$index < $length) { $args[$index] = $transforms[$index]($args[$index]); } return $func(...$args); }); })($func, $transforms); }  }
  namespace _ { function before(int $n, callable $func): callable { $result = null; return function (...$args) use (&$result, &$n, &$func) { if (--$n > 0) { $result = $func(...$args); } return $result; }; }  }
  namespace _ { function ary(callable $func, int $n): callable { return function (...$args) use ($func, $n) { \array_splice($args, $n); return $func(...$args); }; }  }
  namespace _ { function once(callable $func): callable { return before(2, $func); }  }
  namespace _ { function after(int $n, callable $func): callable { return function (...$args) use (&$n, $func) { if (--$n < 1) { return $func(...$args); } }; }  }
  namespace _ { function bindKey($object, string $function, ...$partials): callable { return function (...$args) use ($object, $function, $partials) { $function = \Closure::fromCallable([$object, $function])->bindTo($object, get_class($object)); return $function(...array_merge($partials, $args)); }; }  }
  namespace _ { function negate(callable $predicate): callable { return function () use ($predicate) { return !$predicate(...\func_get_args()); }; }  }
  namespace _ { function delay(callable $func, int $wait = 1, ...$args): int { usleep($wait * 1000); $func(...$args); return 1; }  }
  namespace _ { use function _\internal\baseRest; use function _\internal\shortOut; function partial(callable $func, ...$partials): callable { return baseRest(function ($func, $partials) { $wrapper = function () use ($func, $partials) { $arguments = \func_get_args(); $argsIndex = -1; $argsLength = \func_num_args(); $leftIndex = -1; $leftLength = \count($partials); $args = []; while (++$leftIndex < $leftLength) { $args[$leftIndex] = $partials[$leftIndex]; } while ($argsLength--) { $args[$leftIndex++] = $arguments[++$argsIndex]; } return $func(...$args); }; return shortOut($wrapper); })($func, ...$partials); }  }
  namespace _ { use function _\internal\baseRest; use function _\internal\castSlice; function spread(callable $func, ?int $start = null) { $start = null === $start ? 0 : \max($start, 0); return baseRest(function ($args) use ($start, $func) { $array = $args[$start]; $otherArgs = castSlice($args, 0, $start); if ($array) { $otherArgs = \array_merge($otherArgs, $array); } return $func(...$otherArgs); }); }  }
  namespace _ { function wrap($value, callable $wrapper = null): callable { return partial($wrapper ?? '\_\identity', $value); }  }
  namespace _ { use function _\internal\baseRest; use function _\internal\castSlice; function flip(callable $func): callable { return function (...$values) use ($func) { return \array_reverse($func(...$values), false); }; }  }
  namespace _ { function unary(callable $func): callable { return ary($func, 1); }  }
  namespace _ { function curry(callable $func, ?int $arity = null) { $curry = function ($arguments) use ($func, &$curry, $arity) { $requiredArguments = (new \ReflectionFunction($func))->getNumberOfParameters(); $arity = $arity ?? $requiredArguments; return function (...$args) use ($func, $arguments, $curry, $arity) { if (false !== \array_search(_, $arguments)) { foreach ($arguments as $i => $argument) { if (_ !== $argument) { continue; } $arguments[$i] = current($args); next($args); } } else { $arguments = \array_merge($arguments, $args); } if ($arity <= \count(\array_filter($arguments, function ($value) { return _ !== $value; }))) { return $func(...$arguments); } return $curry($arguments); }; }; return $curry([]); }  }
  namespace _ { function memoize(callable $func, callable $resolver = null) { $memoized = new class($func, $resolver ?? null) { public $cache; private $resolver; private $func; public function __construct(callable $func, ?callable $resolver) { $this->resolver = $resolver; $this->func = $func; } public function __invoke() { $args = \func_get_args(); if ($this->resolver) { $key = \Closure::fromCallable($this->resolver)->bindTo($this)(...$args); } else { $key = &$args[0]; } $cache = $this->cache; if ($cache->has($key)) { return $cache->get($key); } $result = ($this->func)(...$args); $this->cache = $this->cache->set($key, $result); return $result; } }; $memoized->cache = new MapCache; return $memoized; }  }
  namespace _ { use function _\internal\baseRest; function rest(callable $func, ?int $start = null): callable { return baseRest($func, $start); }  }
  namespace _ { function bind(callable $function, $object, ...$partials): callable { return function (...$args) use ($object, $function, $partials) { $function = \Closure::fromCallable($function)->bindTo($object, $function instanceof \Closure ? $object : null); return $function(...array_merge($partials, $args)); }; }  }
  namespace _ { use function _\internal\createMathOperation; function add($augend, $addend) { return createMathOperation(function ($augend, $addend) { return $augend + $addend; }, 0)($augend, $addend); }  }
  namespace _ { use function _\internal\baseIteratee; function maxBy(?array $array, $iteratee) { $iteratee = baseIteratee($iteratee); $result = null; $computed = null; foreach ($array as $key => $value) { $current = $iteratee($value); if (null !== $current && (null === $computed ? ($current === $current) : $current > $computed)) { $computed = $current; $result = $value; } } return $result; }  }
  namespace _ { function max(?array $array): ?int { return $array ? \max($array) : null; }  }
  namespace _ { function clamp(int $number, int $lower, int $upper): int { $number = $number <= $upper ? $number : $upper; $number = $number >= $lower ? $number : $lower; return $number; }  }
  namespace _ { function inRange(float $number, float $start = 0, float $end = 0): bool { if (0.0 === $end) { $end = $start; $start = 0; } return $number >= \min($start, $end) && $number < \max($start, $end); }  }
  namespace _ { function random($lower = null, $upper = null, $floating = null) { if (null === $floating) { if (\is_bool($upper)) { $floating = $upper; $upper = null; } elseif (\is_bool($lower)) { $floating = $lower; $lower = null; } } if (null === $lower && null === $upper) { $lower = 0; $upper = 1; } elseif (null === $upper) { $upper = $lower; $lower = 0; } if ($lower > $upper) { $temp = $lower; $lower = $upper; $upper = $temp; } $floating = $floating || (\is_float($lower) || \is_float($upper)); if ($floating || $lower % 1 || $upper % 1) { $randMax = \mt_getrandmax(); return $lower + \abs($upper - $lower) * \mt_rand(0, $randMax) / $randMax; } return \rand((int) $lower, (int) $upper); }  }
  namespace _ { function isError($value): bool { if (!\is_object($value)) { return false; } return $value instanceof \ParseError || $value instanceof \Error || $value instanceof \Throwable || $value instanceof \SoapFault || $value instanceof \DOMException || $value instanceof \PDOException; }  }
  namespace _ { use SebastianBergmann\Comparator\ComparisonFailure; use SebastianBergmann\Comparator\Factory; function isEqual($value, $other): bool { $factory = new Factory; $comparator = $factory->getComparatorFor($value, $other); try { $comparator->assertEquals($value, $other); return true; } catch (ComparisonFailure $failure) { return false; } }  }
  namespace _ { function eq($value, $other): bool { return $value === $other; }  }
  namespace _ { use function _\internal\arrayMap; use function _\internal\baseIteratee; use function _\internal\basePickBy; function pickBy($object, callable $predicate): \stdClass { if (null === $object) { return new \stdClass; } $props = arrayMap(\array_keys(\get_object_vars($object)), function ($prop) { return [$prop]; }); $predicate = baseIteratee($predicate); return basePickBy($object, $props, function ($value, $path) use ($predicate) { return $predicate($value, $path[0]); }); }  }
  namespace _ { use function _\internal\basePick; use function _\internal\flatRest; function pick($object, $paths): \stdClass { return flatRest(function ($object, $paths) { return basePick($object, $paths); })($object, $paths); }  }
  namespace _ { function lowerFirst(string $string): string { return \lcfirst($string); }  }
  namespace _ { function camelCase(string $string): string { return \lcfirst(\array_reduce(words(\preg_replace("/['\\x{2019}]/u", '', $string)), function ($result, $word) { return $result.capitalize(\strtolower($word)); }, '')); }  }
  namespace _ { function trimEnd(string $string, string $chars = ' '): string { return \rtrim($string, $chars); }  }
  namespace _ { function upperFirst(string $string): string { return \ucfirst($string); }  }
  namespace _ { const reQuotes = "/['\x{2019}]/u"; function lowerCase(string $string) { return \implode(' ', \array_map('\strtolower', words(\preg_replace(reQuotes, '', $string)))); }  }
  namespace _ { const deburredLetters = [ '\xc0' => 'A', '\xc1' => 'A', '\xc2' => 'A', '\xc3' => 'A', '\xc4' => 'A', '\xc5' => 'A', '\xe0' => 'a', '\xe1' => 'a', '\xe2' => 'a', '\xe3' => 'a', '\xe4' => 'a', '\xe5' => 'a', '\xc7' => 'C', '\xe7' => 'c', '\xd0' => 'D', '\xf0' => 'd', '\xc8' => 'E', '\xc9' => 'E', '\xca' => 'E', '\xcb' => 'E', '\xe8' => 'e', '\xe9' => 'e', '\xea' => 'e', '\xeb' => 'e', '\xcc' => 'I', '\xcd' => 'I', '\xce' => 'I', '\xcf' => 'I', '\xec' => 'i', '\xed' => 'i', '\xee' => 'i', '\xef' => 'i', '\xd1' => 'N', '\xf1' => 'n', '\xd2' => 'O', '\xd3' => 'O', '\xd4' => 'O', '\xd5' => 'O', '\xd6' => 'O', '\xd8' => 'O', '\xf2' => 'o', '\xf3' => 'o', '\xf4' => 'o', '\xf5' => 'o', '\xf6' => 'o', '\xf8' => 'o', '\xd9' => 'U', '\xda' => 'U', '\xdb' => 'U', '\xdc' => 'U', '\xf9' => 'u', '\xfa' => 'u', '\xfb' => 'u', '\xfc' => 'u', '\xdd' => 'Y', '\xfd' => 'y', '\xff' => 'y', '\xc6' => 'Ae', '\xe6' => 'ae', '\xde' => 'Th', '\xfe' => 'th', '\xdf' => 'ss', '\x{0100}' => 'A', '\x{0102}' => 'A', '\x{0104}' => 'A', '\x{0101}' => 'a', '\x{0103}' => 'a', '\x{0105}' => 'a', '\x{0106}' => 'C', '\x{0108}' => 'C', '\x{010a}' => 'C', '\x{010c}' => 'C', '\x{0107}' => 'c', '\x{0109}' => 'c', '\x{010b}' => 'c', '\x{010d}' => 'c', '\x{010e}' => 'D', '\x{0110}' => 'D', '\x{010f}' => 'd', '\x{0111}' => 'd', '\x{0112}' => 'E', '\x{0114}' => 'E', '\x{0116}' => 'E', '\x{0118}' => 'E', '\x{011a}' => 'E', '\x{0113}' => 'e', '\x{0115}' => 'e', '\x{0117}' => 'e', '\x{0119}' => 'e', '\x{011b}' => 'e', '\x{011c}' => 'G', '\x{011e}' => 'G', '\x{0120}' => 'G', '\x{0122}' => 'G', '\x{011d}' => 'g', '\x{011f}' => 'g', '\x{0121}' => 'g', '\x{0123}' => 'g', '\x{0124}' => 'H', '\x{0126}' => 'H', '\x{0125}' => 'h', '\x{0127}' => 'h', '\x{0128}' => 'I', '\x{012a}' => 'I', '\x{012c}' => 'I', '\x{012e}' => 'I', '\x{0130}' => 'I', '\x{0129}' => 'i', '\x{012b}' => 'i', '\x{012d}' => 'i', '\x{012f}' => 'i', '\x{0131}' => 'i', '\x{0134}' => 'J', '\x{0135}' => 'j', '\x{0136}' => 'K', '\x{0137}' => 'k', '\x{0138}' => 'k', '\x{0139}' => 'L', '\x{013b}' => 'L', '\x{013d}' => 'L', '\x{013f}' => 'L', '\x{0141}' => 'L', '\x{013a}' => 'l', '\x{013c}' => 'l', '\x{013e}' => 'l', '\x{0140}' => 'l', '\x{0142}' => 'l', '\x{0143}' => 'N', '\x{0145}' => 'N', '\x{0147}' => 'N', '\x{014a}' => 'N', '\x{0144}' => 'n', '\x{0146}' => 'n', '\x{0148}' => 'n', '\x{014b}' => 'n', '\x{014c}' => 'O', '\x{014e}' => 'O', '\x{0150}' => 'O', '\x{014d}' => 'o', '\x{014f}' => 'o', '\x{0151}' => 'o', '\x{0154}' => 'R', '\x{0156}' => 'R', '\x{0158}' => 'R', '\x{0155}' => 'r', '\x{0157}' => 'r', '\x{0159}' => 'r', '\x{015a}' => 'S', '\x{015c}' => 'S', '\x{015e}' => 'S', '\x{0160}' => 'S', '\x{015b}' => 's', '\x{015d}' => 's', '\x{015f}' => 's', '\x{0161}' => 's', '\x{0162}' => 'T', '\x{0164}' => 'T', '\x{0166}' => 'T', '\x{0163}' => 't', '\x{0165}' => 't', '\x{0167}' => 't', '\x{0168}' => 'U', '\x{016a}' => 'U', '\x{016c}' => 'U', '\x{016e}' => 'U', '\x{0170}' => 'U', '\x{0172}' => 'U', '\x{0169}' => 'u', '\x{016b}' => 'u', '\x{016d}' => 'u', '\x{016f}' => 'u', '\x{0171}' => 'u', '\x{0173}' => 'u', '\x{0174}' => 'W', '\x{0175}' => 'w', '\x{0176}' => 'Y', '\x{0177}' => 'y', '\x{0178}' => 'Y', '\x{0179}' => 'Z', '\x{017b}' => 'Z', '\x{017d}' => 'Z', '\x{017a}' => 'z', '\x{017c}' => 'z', '\x{017e}' => 'z', '\x{0132}' => 'IJ', '\x{0133}' => 'ij', '\x{0152}' => 'Oe', '\x{0153}' => 'oe', '\x{0149}' => "'n", '\x{017f}' => 's', ]; const reLatin = '/[\xc0-\xd6\xd8-\xf6\xf8-\xff\x{0100}-\x{017f}]/u'; const rsComboMarksRange = '\\x{0300}-\\x{036f}'; const reComboHalfMarksRange = '\\x{fe20}-\\x{fe2f}'; const rsComboSymbolsRange = '\\x{20d0}-\\x{20ff}'; const rsComboRange = rsComboMarksRange.reComboHalfMarksRange.rsComboSymbolsRange; const rsCombo = '#['.rsComboRange.']#u'; function deburr(string $string): string { $patterns = \array_map( function ($pattern) { return "#$pattern#u"; }, \array_keys(deburredLetters) ); return \preg_replace(rsCombo, '', \preg_replace($patterns, \array_values(deburredLetters), $string)); }  }
  namespace _ { function trimStart(string $string, string $chars = ' '): string { return \ltrim($string, $chars); }  }
  namespace _ { function repeat(string $string, int $n = 1): string { return \str_repeat($string, $n); }  }
  namespace _ { function padStart(string $string, int $length, string $chars = ' '): string { return \str_pad($string, $length, $chars, \STR_PAD_LEFT); }  }
  namespace _ { function trim(string $string, string $chars = ' '): string { return \trim($string, $chars); }  }
  namespace _ { function parseInt($string, int $radix = null): int { if (null === $radix) { $radix = 10; } elseif ($radix) { $radix = +$radix; } return \intval($string, $radix); }  }
  namespace _ { function pad(string $string, int $length, string $chars = ' '): string { return \str_pad($string, $length, $chars, \STR_PAD_BOTH); }  }
  namespace _ { use function _\internal\unicodeWords; const asciiWords = '/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/'; const hasUnicodeWord = '/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/'; function words(string $string, string $pattern = null): array { if (null === $pattern) { if (\preg_match(hasUnicodeWord, $string)) { return unicodeWords($string); } \preg_match_all(asciiWords, $string, $matches); return $matches[0] ?? []; } if (\preg_match_all($pattern, $string, $matches) > 0) { return $matches[0]; } return []; }  }
  namespace _ { function unescape(string $string): string { return \html_entity_decode($string); }  }
  namespace _ { function startCase(string $string) { return \implode(' ', \array_map('\ucfirst', words(\preg_replace("/['\x{2019}]/u", '', $string)))); }  }
  namespace _ { function replace(string $string, string $pattern, $replacement = null): string { $callback = function (array $matches) use ($replacement): ?string { if (!\array_filter($matches)) { return null; } return \is_callable($replacement) ? $replacement(...$matches) : null; }; if (\preg_match(reRegExpChar, $pattern)) { if (!\is_callable($replacement)) { return \preg_replace($pattern, \is_string($replacement) || \is_array($replacement) ? $replacement : '', $string); } return \preg_replace_callback($pattern, $callback, $string); } return \str_replace($pattern, \is_string($replacement) || \is_array($replacement) ? $replacement : '', $string); }  }
  namespace _ { function snakeCase(string $string): string { return \implode('_', \array_map('\strtolower', words(\preg_replace("/['\x{2019}]/u", '', $string)))); }  }
  namespace _ { const reRegExpChar = '/([\\^$.*+?()[\]{}|])/'; function escapeRegExp(string $string): string { return \preg_replace(reRegExpChar, '\\\$0', $string); }  }
  namespace _ { function toUpper(string $string): string { return \strtoupper($string); }  }
  namespace _ { function startsWith(string $string, string $target, int $position = null): bool { $length = \strlen($string); $position = null === $position ? 0 : +$position; if ($position < 0) { $position = 0; } elseif ($position > $length) { $position = $length; } return $position >= 0 && \substr($string, $position, \strlen($target)) === $target; }  }
  namespace _ { function capitalize(string $string): string { return \ucfirst(\mb_strtolower($string)); }  }
  namespace _ { use function _\internal\castSlice; use function _\internal\hasUnicode; use function _\internal\stringSize; use function _\internal\stringToArray; const DEFAULT_TRUNC_LENGTH = 30; const DEFAULT_TRUNC_OMISSION = '...'; function truncate($string, array $options = []) { $separator = $options['separator'] ?? null; $length = $options['length'] ?? DEFAULT_TRUNC_LENGTH; $omission = $options['omission'] ?? DEFAULT_TRUNC_OMISSION; $strSymbols = null; $strLength = \strlen($string); if (hasUnicode($string)) { $strSymbols = stringToArray($string); $strLength = \count($strSymbols); } if ($length >= $strLength) { return $string; } $end = $length - stringSize($omission); if ($end < 1) { return $omission; } $result = $strSymbols ? \implode('', castSlice($strSymbols, 0, $end)) : \substr($string, 0, $end); if (null === $separator) { return $result.$omission; } if ($strSymbols) { $end += \strlen($result) - $end; } if (\preg_match(reRegExpChar, $separator)) { if (\preg_match($separator, \substr($string, 0, $end))) { $match = null; $newEnd = null; $substring = $result; if (\preg_match_all($separator, $substring, $match, PREG_OFFSET_CAPTURE)) { $newEnd = \end($match[0])[1]; } $result = \substr($result, 0, null === $newEnd ? $end : $newEnd); } } elseif (\strpos($string, $separator) !== $end) { $index = \strrpos($result, $separator); if (false !== $index && $index > -1) { $result = \substr($result, 0, $index); } } return $result.$omission; }  }
  namespace _ { function upperCase(string $string) { return \implode(' ', \array_map('\strtoupper', words(\preg_replace(reQuotes, '', $string)))); }  }
  namespace _ { function endsWith(string $string, string $target, int $position = null): bool { $length = \strlen($string); $position = null === $position ? $length : +$position; if ($position < 0) { $position = 0; } elseif ($position > $length) { $position = $length; } $position -= \strlen($target); return $position >= 0 && \substr($string, $position, \strlen($target)) === $target; }  }
  namespace _ { const reEsTemplate = "\$\{([^\\}]*(?:\\.[^\\}]*)*)\}"; const reNoMatch = '($^)'; const reUnescapedString = "#([\'\n\r\x{2028}\x{2029}\\\])#u"; const stringEscapes = [ '\\' => '', '\n' => 'n', '\r' => 'r', '\u2028' => 'u2028', '\u2029' => 'u2029', ]; function template(string $string, array $options = []): callable { $options = \array_merge_recursive(\_::$templateSettings, $options); $interpolate = $options['interpolate'] ?? reNoMatch; $reDelimiters = \implode('|', [ ($options['escape'] ?? reNoMatch), ($interpolate === \_::reInterpolate ? reEsTemplate : reNoMatch), $interpolate, ($options['evaluate'] ?? reNoMatch), ]); $string = \preg_replace_callback('#'.$reDelimiters.'#u', function ($matches) { list(, $escapeValue, $interpolateValue, $esTemplateValue, $evaluateValue, ) = \array_merge($matches, \array_fill(\count($matches), 5 - \count($matches), null)); $interpolateValue = $interpolateValue ?: $esTemplateValue; $source = ''; if ($escapeValue) { $escapeValue = \trim($escapeValue); $source .= "<?=__e(\$${escapeValue});?>"; } if ($evaluateValue) { $source .= "<?php \n${evaluateValue} ?>"; } if ($interpolateValue) { $interpolateValue = \trim($interpolateValue ?? $esTemplateValue); $interpolateValue = \preg_replace('#^([\p{L}\p{N}_]+)$#u', '$$1', $interpolateValue); $source .= "<?=${interpolateValue};?>"; } return $source; }, $string); $string = \preg_replace_callback(reUnescapedString, function ($chr) { return stringEscapes[$chr[0]] ?? $chr[0]; }, $string); $imports = $options['imports'] ?? []; return new class($string, $imports) { public $source; private $imports; public function __construct(string $source, array $imports) { $this->source = $source; $this->imports = $imports; } public function __invoke(array $arguments = []) { $imports = ''; foreach ($this->imports as $import => $alias) { if (\class_exists($import)) { $imports .= "use $import as $alias;"; } elseif (\function_exists($import)) { $imports .= "use function $import as $alias;"; } } $file = \tempnam(\sys_get_temp_dir(), 'lodashphp'); if (!$file) { throw new \RuntimeException('Unable to create temporary file for template'); } \file_put_contents($file, "<?php namespace __template; $imports (function() { extract(".\var_export($arguments, true).'); ?>'.$this->source.'<?php })()?>'); $content = attempt(function () use ($file) { \ob_start(); require_once $file; return \ob_get_clean(); }); \unlink($file); return $content; } }; }  }
  namespace _ { function padEnd(string $string, int $length, string $chars = ' '): string { return \str_pad($string, $length, $chars, \STR_PAD_RIGHT); }  }
  namespace _ { function split(string $string, string $separator, int $limit = 0): array { if (\preg_match(reRegExpChar, $separator)) { return \preg_split($separator, $string, $limit ?? -1, PREG_SPLIT_DELIM_CAPTURE) ?: []; } $result = \explode($separator, $string); if ($limit > 0) { return \array_splice($result, 0, $limit); } return $result; }  }
  namespace _ { function toLower(string $string): string { return \strtolower($string); }  }
  namespace _ { function escape(string $string) { return \htmlentities($string); }  }
  namespace _ { function kebabCase(string $string) { return \implode('-', \array_map('\strtolower', words(\preg_replace("/['\x{2019}]/u", '', $string)))); }  }
  namespace _ { use _\internal\Traits\CacheDataTrait; use function _\internal\assocIndexOf; final class ListCache implements CacheInterface { use CacheDataTrait; public function __construct(iterable $entries = null) { $this->clear(); if (null !== $entries) { foreach ($entries as $key => $entry) { $this->set($key, $entry); } } } final public function set($key, $value): CacheInterface { $index = assocIndexOf($this->__data__, $key); if ($index < 0) { ++$this->size; $this->__data__[] = [$key, $value]; } else { $this->__data__[$index][1] = $value; } return $this; } final public function get($key) { $index = assocIndexOf($this->__data__, $key); return $index < 0 ? null : $this->__data__[$index][1]; } final public function has($key): bool { return assocIndexOf($this->__data__, $key) > -1; } final public function clear() { $this->__data__ = []; $this->size = 0; } final public function delete($key) { $index = assocIndexOf($this->__data__, $key); if ($index < 0) { return false; } $lastIndex = \count($this->__data__) - 1; if ($index === $lastIndex) { \array_pop($this->__data__); } else { \array_splice($this->__data__, $index, 1); } --$this->size; return true; } }  }